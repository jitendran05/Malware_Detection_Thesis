import pandas as pd
import numpy as np
import sklearn
import os
import pandas as pd
import numpy
import numpy as np
import pickle
import sklearn.ensemble as ek
from sklearn import tree, linear_model
from sklearn.feature_selection import SelectFromModel

from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import confusion_matrix
from sklearn.pipeline import make_pipeline
from sklearn import preprocessing
from sklearn import svm
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split 
from sklearn.ensemble import AdaBoostClassifier,RandomForestClassifier
from sklearn.naive_bayes import GaussianNB
import sklearn.ensemble as ske
from sklearn import tree, linear_model
from androguard.misc import *
from sklearn.metrics import classification_report
from yellowbrick.classifier import ClassificationReport
from sklearn.metrics import log_loss
from matplotlib import pyplot
from numpy import array
from sklearn import preprocessing
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix,accuracy_score,roc_auc_score,classification,roc_curve
import util
import hmm





benign_df = pd.read_csv('./csv/benign.csv')
malign_df = pd.read_csv('./csv/malign.csv')

benign_df['res']=1
malign_df['res']=0

# concatenating dataframe of benign and malign
#frames = [benign_df,malign_df]
df = pd.concat([benign_df,malign_df])
# df.reset_index()

# dropping the first 2 columns as the first 2 columns are not useful
df.drop(df.columns[[0, 0]], axis=1, inplace=True)

X = df.drop(['res'],axis=1)

y = df['res']

print("Actual Dimenions of feature space is ", X.shape)

#Feature Selection
print("============================Feature Selection===============================")
extratrees = RandomForestClassifier(n_estimators=50).fit(X,y)
model = SelectFromModel(extratrees, prefit=True)
X_new = model.transform(X)
nb_features = X_new.shape[1]



X_train, X_test, y_train, y_test =train_test_split(X_new, y ,test_size=0.3)
features = []
print('%i features identified as important:' % nb_features)


#important features scored
indices = np.argsort(extratrees.feature_importances_)[::-1][:nb_features]
for f in range(nb_features):
    print("%d. feature %s (%f)" % (f + 1, df.columns[2+indices[f]], extratrees.feature_importances_[indices[f]]))


for f in sorted(np.argsort(extratrees.feature_importances_)[::-1][:nb_features]): 
    features.append(df.columns[2+f])


def plot_roc_curve(fpr, tpr):  
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.show()

hmm_model=hmm.hmm_func()

algorithms = {

        "HMM": hmm_model,

        "DecisionTree": tree.DecisionTreeClassifier(max_depth=1),

        "RandomForest": RandomForestClassifier(n_estimators=1),

        "GradientBoosting": ske.GradientBoostingClassifier(n_estimators=1),

        "AdaBoost": ske.AdaBoostClassifier(n_estimators=1)

    }

results = {}
print("\nNow testing algorithms")
for algo in algorithms:
    clf = algorithms[algo]
    clf.fit(X_train, y_train)
    score = clf.score(X_test, y_test)
    results[algo] = score
    #print("%s : %f %%" % (algo, score*100))
    y_pred = clf.predict(X_train)
    pred=clf.predict_proba(X_test)   
    print( algo + ":Confusion Matrix: ", confusion_matrix(y_train, y_pred))
    print ( algo + ":Accuracy : ", accuracy_score(y_train,y_pred)*100)
    print(algo + ":Test set")
    y_pred = clf.predict(X_test)
    print(algo + ":Confusion Matrix: ", confusion_matrix(y_test, y_pred))
    print (algo + ":Accuracy : ", accuracy_score(y_test,y_pred)*100)
    #confusion Matrix
    matrix =confusion_matrix(y_test, y_pred)
    class_names=[0,1] 
    fig, ax = plt.subplots()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names)
    plt.yticks(tick_marks, class_names)
    sns.heatmap(pd.DataFrame(matrix), annot=True, cmap="YlGnBu" ,fmt='g')
    ax.xaxis.set_label_position("top")
    plt.tight_layout()
    fig.canvas.set_window_title(algo)
    plt.title('Confusion matrix', y=1.1)
    plt.ylabel('Actual label')
    plt.xlabel('Predicted label')
    plt.show()
    #ROC_AUC curve
    probs = clf.predict_proba(X_test) 
    probs = probs[:, 1]  
    auc = roc_auc_score(y_test, probs)  
    print('AUC: %.2f' % auc)
    le = preprocessing.LabelEncoder()
    y_test1=le.fit_transform(y_test)
    fpr, tpr, thresholds = roc_curve(y_test1, probs)
    plot_roc_curve(fpr, tpr)
    #Classification Report
    target_names = ['Yes', 'No']
    prediction=clf.predict(X_test)
    print(classification_report(y_test, prediction, target_names=target_names))
    classes = ["Yes", "No"]
    visualizer = ClassificationReport(clf, classes=classes, support=True)
    visualizer.fit(X_train, y_train)  
    visualizer.score(X_test, y_test)  
    g = visualizer.poof()

winner = max(results, key=results.get)
print('\nWinner algorithm is %s with a %f %% success' % (winner, results[winner]*100))

# Save the algorithm and the feature list for later predictions
print('Saving algorithm and feature list in classifier directory...')
#joblib.dump(algorithms[winner], 'classifier/classifier.pkl')
open('classifier/classifier.pkl', 'wb').write(pickle.dumps(algorithms[winner])) 
open('classifier/features.pkl', 'wb').write(pickle.dumps(features)) 

print('Saved')


clf = algorithms[winner]
res = clf.predict(X_test)
mt = confusion_matrix(y_test, res)

from androguard.misc import *

from PIL import ImageTk,Image
import tkinter as tk
from tkinter import *
from tkinter import filedialog
from PIL import Image

#user define function
def classify():
    textbox1.delete('1.0',"end-1c")
    filename = filedialog.askopenfilename(initialdir =  "/", title = "Select A File", filetype =((("Executable file",".exe"),("Executable file",".apk")) ))
    textbox.delete('1.0', "end-1c")
    textbox.insert("end-1c", filename)
    DATASET_PATH = "/Dataset"
    apk=filename
    data = util.PreProcess(DATASET_PATH)
    print("Analyzing APK -- ",os.path.basename(apk))
    print("-------------------------------------------------------------")
    a,d,dx = AnalyzeAPK(apk)
    feats = list()
    feats1 = list()
    feats2 = list()
    res = {}

    feats += (data.makeHotVector([data.vocabPerm.index(p) for p in a.get_permissions() if p in data.vocabPerm], \
                                    data.vocabLengths["perm"])).tolist()

    for i in range(len(feats)):
        res['perm_' +str(i+1)] =feats[i]

    feats1 += (data.makeHotVector([data.vocabServ.index(p) for p in a.get_services() if p in data.vocabServ], \
                                    data.vocabLengths["serv"])).tolist()

    for i in range(len(feats1)):
        res['serv_' +str(i+1)] =feats1[i]


    feats2 += (data.makeHotVector([data.vocabRecv.index(p) for p in a.get_receivers()if p in data.vocabRecv], \
                                    data.vocabLengths["recv"])).tolist()


    for i in range(len(feats2)):
        res['recv_' +str(i+1)] =feats2[i]

    # test_feats = np.array(feats)
    print("Done")


   # clf = joblib.load('classifier/classifier.pkl')
    clf = pickle.loads(open(os.path.join('classifier/classifier.pkl'),'rb').read())
    features = pickle.loads(open(os.path.join('classifier/features.pkl'),'rb').read())
    data1 = res
    android_features = list(map(lambda x:data1[x], features))

    res= clf.predict([android_features])[0]
    print ('The file is ' +str(res))


    if res == 0:
        print("Malign")
        textbox1.insert("end-1c","Malign")
        load = Image.open('cross.jpg')
        load = load.resize((630, 400), Image.ANTIALIAS)
        render = ImageTk.PhotoImage(load)
        img = Label(image=render)
        img.image = render
        img.place(x=75, y=235)
    else:
        print("Bengin")
        textbox1.insert("end-1c","Bengin")
        load = Image.open('tick.jpg')
        load = load.resize((630, 400), Image.ANTIALIAS)
        render = ImageTk.PhotoImage(load)
        img = Label(image=render)
        img.image = render
        img.place(x=75, y=235)
# classify("testApks/messenger.apk") 

app = tk.Tk()

HEIGHT = 700
WIDTH = 700

app.resizable(0,0)
canvas = Canvas(width=1300, height=700)
canvas.pack()
filename=('malware.png')
load = Image.open(filename)
load = load.resize((1300, 700), Image.ANTIALIAS)
render = ImageTk.PhotoImage(load)
img = Label(image=render)
img.image = render
load = Image.open(filename)
img.place(x=1, y=1)


frame = tk.Frame(app,  bg='#3e3e32', bd=5)
frame.place(relx=0.3, rely=0.1, relwidth=0.5, relheight=0.25, anchor='n')
#frame_window = C.create_window(100, 40, window=frame)

textbox = tk.Text(frame, font=5,width="30",height=2)
textbox.grid(row=2, column=1)

submit = tk.Button(frame,font=40, text='BROWSE',height=1,width="13",command=lambda: classify())
submit.grid(row=2, column=2,padx=20,pady=20)

textbox1 = tk.Text(frame, font=10,width="30",height=2)
textbox1.grid(row=3, column=1)

lower_frame = tk.Frame(app, bg='#3e3e32', bd=10)
lower_frame.place(relx=0.3, rely=0.32, relwidth=0.5, relheight=0.6, anchor='n')


bg_color = 'white'
results = tk.Text(lower_frame)
results.config(font=40, bg=bg_color)
results.place(relwidth=1, relheight=1)


app.mainloop()









